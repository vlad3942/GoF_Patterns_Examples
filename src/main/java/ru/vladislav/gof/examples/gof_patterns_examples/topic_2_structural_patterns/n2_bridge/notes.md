## Bridge

### Исходная ситуация
<img src="./imgs/img_1.png">

Существует несколько вариантов отчётов за разные временные промежутки.
Клиент использует все отчёты через общий интерфейс, как-то создаёт нужный ему вид отчёта и выводит каким-то единым способом.

### Проблема
Появилось требование выводить все существующие отчёты в разных форматах: MS Word, Excel, JSON, XML...

### Решение
<img src="./imgs/img_2.png">

Добавляем новую иерархию классов ReportOutput, а в базовом классе Report объявляем ссылку на абстрактный класс (или интерфейс) ReportOutput.
Все конкретные реализации Report будут использовать методы ReportOutput для своего вывода.

### Плюсы
* Позволяет разделить оси изменений для двух иерархий сущностей.
* Позволяет избежать комбинаторного взрыва.
* Отделяем абстракцию логики печати от логики вывода (форматирования вывода).

### Недостатки

* Неустойчивый. 
    * Н-р, если какой-то отчёт нужен только для одного типа вывода. Вместо реализации API использовали прямые вызовы и всё сломалось.
    * Или если какой-то специфичный отчёт требует особого вывода для определённого формата. Н-р, месячный отчёт хочет добавлять логотип компании при выводе в Word. Проверка на инстенс создаст прямую зависимость, чего мы пытаемся избежать. И паттерн ломается...
* Повышает сложность.
* Вызывает желание вызывать напрямую методы Интерфейса ReportOutput, хотя на самом деле правильно вызывать методы из класса Report, а уже абстрактный класс Report должен вызывать всё что нужно из класса ReportOutput.

<p><i> Этот Шаблон используется только когда есть строго две оси изменений. (или больше)</i></p>

<p><i>Родственные шаблоны: Abstract Factory, Adapter.</i></p>

### Задача:
Ты разрабатываешь приложение для создания различных видов уведомлений (например, СМС, электронные письма и пуш-уведомления). В приложении есть разные типы уведомлений: важные уведомления и обычные уведомления. У каждого типа уведомлений могут быть разные каналы доставки — СМС, электронная почта или пуш-уведомления. Твоя задача — реализовать систему с использованием паттерна Bridge, чтобы отделить логику типов уведомлений от логики их отправки через разные каналы.

### Требования:
1. Создай абстракцию для уведомлений — класс Notification, который будет использовать интерфейс для отправки уведомлений через разные каналы.
2. Раздели классы уведомлений на два типа: важные и обычные уведомления. Эти классы должны наследовать абстрактный класс Notification.
3. Создай интерфейс NotificationSender, который будет определять метод для отправки уведомлений.
4. Реализуй несколько классов, которые будут отправлять уведомления через разные каналы: СМС, электронная почта и пуш-уведомления. Эти классы должны реализовать интерфейс NotificationSender.
5. Используй паттерн Bridge для отделения типа уведомления от способа его отправки. Это позволит легко добавлять новые способы отправки уведомлений или новые типы уведомлений.