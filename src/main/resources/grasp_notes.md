
# Part_1 → GRASP

## I. Information expert
<b>Информационный эксперт: </b><br>
<i>Задача:</i> В системе должна аккумулироваться, рассчитываться и обрабатываться какая-либо информация.
<br>
<i>Решение:</i> Дать возможность объекту, содержащему информацию обрабатывать её. 
<br>
Т.е. информация должна обрабатываться тем объектом, который её содержит. 
<br>

## II. Creator
<b>Создатель: </b>
Каждый класс должен создаваться тем классом, который его непосредственно использует.

> Имплементация принципа инкапсуляции. Объект должен создаваться там где он нужен.

Пример:

```
+---+   +-------+    +----+    +-------+
| M | → | Order | ♦- | IO | ♦- | Goods |
+---+   +-------+    +----+    +-------+
```

Не правильно<br>
main:
```java
var goods = new Goods();
var oi = new OrderItem();
oi.setGoods(goods);
var order = new Order();
order.setOrderItem(oi);
```
(Main зависит от всех объектов, и все объекты создаются в main, нарушается принцип Information Expert, так-как инициализацией объектов занимается некоторый класс Main, таким образом он отвечает за процесс создание объектов из информации которая в нём не хранится)

Правильно: <br>
Main:

```java

import java.util.List;

class Goods {

    Goods(String str) {
        //...
    }
}

class OrderItem {
    private Goods goods;

    OrderItem(String str) {
        this.goods = new Goods(str);
    }
}

class Order {
    private List<OrderItem> orderItems;

    Order(String str) {
        orderItems = List.of(new OrderItem(str));
    }
}

class Main {
    public static void main(String[] args) {
        Order order = new Order(args[0]);
        order.doSomething();
        //...
    }
}
```
(Каждый класс сам создаёт те классы которые использует, при этом можно передать какую-то информацию в виде примитивов или стандартных классов)

> Тут правда возникает проблема с тем что сами классы становятся сильно связанными между собой и мы не можем отдельно использовать класс <i>Order</i> без классов <i>OrderItem</i> и <i>Goods</i>...

## III. Controller
Сосредоточить однотипные обращения в одном объекте контроллера.
Например, многопоточные обращения клиентов к системе.
Это позволит сосредоточить всю обработку многопоточности в одном классе, 
превращая многопоточные обращения в однопоточные.

```
  USER
↓↓↓↓↓↓↓↓↓ ( process() )
+------------+                              +--------+
| Controller |                              | Worker | → class A
+------------+ ----(new Worker(...))----->  +--------+ → class B
| process()  |                              | run()  | → class C
+------------+                              +--------+
```

## IV. Low Coupling
> Проистекает из принципа инкапсуляции.

<i>Формулировка:</i> В системе должно быть минимально необходимое количество взаимосвязей.

```
+---+   +-------+    +----+    +-------+
| M | → | Order | ♦- | IO | ♦- | Goods |
+---+   +-------+    +----+    +-------+
```

## V. High Cohesion
Все объекты системы должны быть максимально зацеплены (связаны).
Имеется ввиду, компоновать однородные данные в одни классы, в одни модули, директории, библиотеки и т.д.
И все разнородные данные нужно разделить, выносить в отдельные модули, объекты и т.д.

## VI. Полиморфизм
> Любой if в системе можно заменить на полиморфное поведение.

Исходный пример с условием:
```java
class Main {
    public static void main(String[] args) {
        boolean flag = Boolean.parseBoolean(args[0]);
        Main main = new Main();
        main.doSomething(flag);
    }
    
    public void doSomething(boolean flag) {
        if (flag) {
            System.out.println("Hello");
        } else {
            System.out.println("World");
        }
    }
}
```

Полиморфный пример:
```java
class Main {
    public static void main(String[] args) {
        //Предполагается что конкретная 
        // имплементация будет получена из конфигурации.
        var clazz = Class.forName(args[0]);
        var printer = (Printer) clazz.getConstructors()[0].newInstance();
        Main main = new Main();
        main.doSomething(printer);
    }
    
    public void doSomething(Printer printer) {
        printer.print();
    }
}

interface Printer {
    void print();
}

class HelloPrinter implements Printer {
    @Override
    public void print() {
        System.out.println("Hello");
    }
}

class WorldPrinter implements Printer {
    @Override
    public void print() {
        System.out.println("World");
    }
}
```

> Полиморфное поведение имеет преимущество над условием, когда одно и то же условие используется в системе несколько раз для принятия какого-то решения.
> В этом случае лучше вынести одни ветки условий в один класс, а другие в другой и отнаследовать их от общего интерфейса, а условие использовать один раз для выбора создаваемого объекта.

## VII. Pure Fabrication (искусственный)
Так называется класс, который обеспечивает в системе Low Coupling и High Cohesion, но не существует в реальном мире или в предметной области (не отражает объекты предметной области).
<br>Пример Pure Fabrication - Любой Фасад.

## VIII. Indirection | Inversion of Control | Dependency Injection
> Помнить: обращение к любому классу должно проходить через его интерфейс.
> Это делает нашу систему более гибкой, позволяя внедрить любое количество функциональности между классам при необходимости, а так же применить большую часть паттернов. 

Пример:
```
+---+   +---+
| A | → | B |
+---+   +---+
```
Класс A использует класс B. 
Другой класс может спокойно переиспользовать класс B.
Но не может переиспользовать класс A отдельно от класса B.
То есть класс A не компилируется без класса B.
Мы готовы написать свою реализацию класса B - B1.
Для этого используется Indirection, мы разворачиваем зависимости.

```
+---+   +----+
| A | → | BI |
+---+   +----+
  ↑        ▲
  |        |
  |    +---+----+
  |    |        |
  |  +---+    +----+
  |  | B |    | B1 |
  |  +---+    +----+
  |              ↑  
+---+            |  
| C |------------+
+---+
```
Теперь класс A зависит не от класса B, а от интерфейса BI, который теперь принадлежит классу A (и хранится где-то рядом с ним).

## IX. Protected variations
Защита от изменений и открытость для расширения.

Мы должны обеспечить возможность расширять систему так, чтобы старый функционал не ломался.
